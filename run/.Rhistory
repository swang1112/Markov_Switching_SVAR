}
u = B %*% t(Epsilon)
t(u)
}
.get_kl0 = function(theta, u, C, kernel = "gaussian", bw = 1.06){
Q  = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
xx = t(solve(C %*% Q) %*% t(u))
out = 0
for (i in 1:2) {
kd    = density(xx[,i],bw = bw, kernel = "gaussian",from = min(xx[,i]) - 2*bw, to = max(xx[,i]) + 2*bw, n = 2^12)
min   = kd$x[1]
grid  = kd$x[2]-min
out   = out + klik(theta, xx[,i], kd, grid, min)
}
out
}
# DGP ---------------------------------------------------------------------
Size = 10
Tob  = 240
dof  = c(3,3)
rho   = 0.4 #cov(u1,u2)
theta = pi/3
C     = matrix(c(1, 0, rho, sqrt(1-rho^2)), nrow = 2, ncol = 2, byrow = T)
Q     = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
B     = C %*% Q
U = vector("list", length = Size)
U = pbapply::pblapply(U, .make_dat, Tob = Tob, dof = dof, B = B, cl = 7)
# 1 sample ----------------------------------------------------------------
U1 = U[sample(1:Size, 1)][[1]]
kl = pbapply::pbapply(theta_star, .get_kl0, u = U1, C = C)
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C)
theta_star = seq(0, pi, length.out = 1000)
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C)
theta_star = seq(0, pi, length.out = 1000) %>% as.matrix()
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C)
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = 7)
plot(theta_star, kl)
plot(theta_star, kl, type = "l")
abline(v = theta)
library(magrittr)
library(MKLE)
rm(list = ls())
# fun ---------------------------------------------------------------------
.make_dat = function(x, Tob, dof, B, dist = 'tdist'){
Epsilon = matrix(NA, nrow = Tob, ncol = 2)
for (k in 1:2) {
Epsilon[,k] = rt(Tob, dof[k])*sqrt((dof[k] - 2)/dof[k])
}
u = B %*% t(Epsilon)
t(u)
}
.get_kl0 = function(theta, u, C, kernel = "gaussian", bw = 1.06){
Q  = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
xx = t(solve(C %*% Q) %*% t(u))
out = 0
for (i in 1:2) {
kd    = density(xx[,i],bw = bw, kernel = "gaussian",from = min(xx[,i]) - 2*bw, to = max(xx[,i]) + 2*bw, n = 2^12)
min   = kd$x[1]
grid  = kd$x[2]-min
out   = out + klik(theta, xx[,i], kd, grid, min)
}
out
}
# DGP ---------------------------------------------------------------------
Size = 10
Tob  = 240
dof  = c(3,10)
rho   = 0.4 #cov(u1,u2)
theta = pi/3
C     = matrix(c(1, 0, rho, sqrt(1-rho^2)), nrow = 2, ncol = 2, byrow = T)
Q     = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
B     = C %*% Q
U = vector("list", length = Size)
U = pbapply::pblapply(U, .make_dat, Tob = Tob, dof = dof, B = B, cl = 7)
# 1 sample ----------------------------------------------------------------
U1 = U[sample(1:Size, 1)][[1]]
theta_star = seq(0, pi, length.out = 1000) %>% as.matrix()
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = 7)
plot(theta_star, kl, type = "l")
abline(v = theta)
U1 = U[sample(1:Size, 1)][[1]]
theta_star = seq(0, pi, length.out = 1000) %>% as.matrix()
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = 7)
plot(theta_star, kl, type = "l")
abline(v = theta)
U1 = U[sample(1:Size, 1)][[1]]
theta_star = seq(0, pi, length.out = 1000) %>% as.matrix()
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = 7)
plot(theta_star, kl, type = "l")
abline(v = theta)
.get_B = function(theta, C){
Q  = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
xx = t(solve(C %*% Q) %*% t(u))
}
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
.get_B = function(theta, C){
Q  = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
C %*% Q
}
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C, cl = 7)
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
Bs %>% dim
Bs
plot(Bs[1,], kl, type = "l")
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
plot(Bs[1,], kl, type = "l")
abline(v = B[1,1])
# 1 sample ----------------------------------------------------------------
U1 = U[sample(1:Size, 1)][[1]]
theta_star = seq(0, 2*pi, length.out = 1000) %>% as.matrix()
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = 7)
plot(theta_star, kl, type = "l")
abline(v = theta)
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
plot(Bs[1,], kl, type = "l")
abline(v = B[1,1])
# 1 sample ----------------------------------------------------------------
U1 = U[sample(1:Size, 1)][[1]]
theta_star = seq(-pi, pi, length.out = 1000) %>% as.matrix()
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = 7)
plot(theta_star, kl, type = "l")
abline(v = theta)
warnings()
kl
abline(v = theta)
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
plot(Bs[1,], kl, type = "l")
# 1 sample ----------------------------------------------------------------
U1 = U[sample(1:Size, 1)][[1]]
theta_star = seq(0, pi, length.out = 1000) %>% as.matrix()
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = 7)
plot(theta_star, kl, type = "l")
abline(v = theta)
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
plot(Bs[1,], kl, type = "l")
abline(v = B[1,1])
B %>% c
B
par(mfrow = c(2,2))
plot(Bs[1,], kl, type = "l")
abline(v = B[1,1])
plot(Bs[2,], kl, type = "l")
abline(v = B[2,1])
plot(Bs[3,], kl, type = "l")
abline(v = B[1,2])
plot(Bs[4,], kl, type = "l")
abline(v = B[2,2])
# 1 sample ----------------------------------------------------------------
U1 = U[sample(1:Size, 1)][[1]]
theta_star = seq(0, pi, length.out = 1000) %>% as.matrix()
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = 7)
plot(theta_star, kl, type = "l")
abline(v = theta)
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
par(mfrow = c(2,2))
plot(Bs[1,], kl, type = "l", main = '[1,1]')
abline(v = B[1,1])
plot(Bs[2,], kl, type = "l", main = '[2,1]')
abline(v = B[2,1])
plot(Bs[3,], kl, type = "l", main = '[1,2]')
abline(v = B[1,2])
plot(Bs[4,], kl, type = "l", main = '[2,2]')
abline(v = B[2,2])
par(mfrow = c(1,1))
plot(theta_star, kl, type = "l")
abline(v = theta)
par(mar = c(1,1,1,1))
plot(theta_star, kl, type = "l")
abline(v = theta)
par(mar = c(2,2,1,1))
plot(theta_star, kl, type = "l")
abline(v = theta)
par(mar = c(1,2,1,2))
plot(theta_star, kl, type = "l")
abline(v = theta)
par(mar = c(2,1,2,1))
plot(theta_star, kl, type = "l")
abline(v = theta)
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
par(mfrow = c(2,2))
plot(Bs[1,], kl, type = "l", main = '[1,1]')
abline(v = B[1,1])
plot(Bs[2,], kl, type = "l", main = '[2,1]')
abline(v = B[2,1])
plot(Bs[3,], kl, type = "l", main = '[1,2]')
abline(v = B[1,2])
plot(Bs[4,], kl, type = "l", main = '[2,2]')
abline(v = B[2,2])
par(mar = c(2,1,2,1))
plot(theta_star, kl, type = "l", main = 'solid line: true theta')
abline(v = theta)
plot(theta_star, kl, type = "l", main = 'solid line: truth', xlab = 'theta')
par(mar = c(3,1,2,1))
plot(theta_star, kl, type = "l", main = 'solid line: truth', xlab = 'theta')
abline(v = theta)
par(mfrow = c(1,1))
U1 = U[sample(1:Size, 1)][[1]]
theta_star = seq(0, pi, length.out = 1000) %>% as.matrix()
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = parallel::detectCores()-1)
par(mar = c(2,1,2,1))
plot(theta_star, kl, type = "l", main = 'solid line: true theta')
abline(v = theta)
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
par(mfrow = c(2,2))
plot(Bs[1,], kl, type = "l", main = 'solid line: true [1,1]')
abline(v = B[1,1])
plot(Bs[2,], kl, type = "l", main = 'solid line: true [2,1]')
abline(v = B[2,1])
plot(Bs[3,], kl, type = "l", main = 'solid line: true [1,2]')
abline(v = B[1,2])
plot(Bs[4,], kl, type = "l", main = 'solid line: true [2,2]')
abline(v = B[2,2])
par(mfrow = c(1,1))
library(magrittr)
library(MKLE)
rm(list = ls())
# fun ---------------------------------------------------------------------
.make_dat = function(x, Tob, dof, B, dist = 'tdist'){
Epsilon = matrix(NA, nrow = Tob, ncol = 2)
for (k in 1:2) {
Epsilon[,k] = rt(Tob, dof[k])*sqrt((dof[k] - 2)/dof[k])
}
u = B %*% t(Epsilon)
t(u)
}
.get_kl0 = function(theta, u, C, kernel = "gaussian", bw = 1.06){
Q  = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
xx = t(solve(C %*% Q) %*% t(u))
out = 0
for (i in 1:2) {
kd    = density(xx[,i],bw = bw, kernel = "gaussian",from = min(xx[,i]) - 2*bw, to = max(xx[,i]) + 2*bw, n = 2^12)
min   = kd$x[1]
grid  = kd$x[2]-min
out   = out + klik(theta, xx[,i], kd, grid, min)
}
out
}
.get_B = function(theta, C){
Q  = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
C %*% Q
}
# DGP ---------------------------------------------------------------------
Size = 10
Tob  = 240
dof  = c(100,100)
rho   = 0.4 #cov(u1,u2)
theta = pi/3
C     = matrix(c(1, 0, rho, sqrt(1-rho^2)), nrow = 2, ncol = 2, byrow = T)
Q     = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
B     = C %*% Q
U = vector("list", length = Size)
U = pbapply::pblapply(U, .make_dat, Tob = Tob, dof = dof, B = B, cl = parallel::detectCores()-1)
# 1 sample ----------------------------------------------------------------
U1 = U[sample(1:Size, 1)][[1]]
theta_star = seq(0, pi, length.out = 1000) %>% as.matrix()
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = parallel::detectCores()-1)
par(mar = c(2,1,2,1))
plot(theta_star, kl, type = "l", main = 'solid line: true theta')
abline(v = theta)
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
par(mfrow = c(2,2))
plot(Bs[1,], kl, type = "l", main = 'solid line: true [1,1]')
abline(v = B[1,1])
plot(Bs[2,], kl, type = "l", main = 'solid line: true [2,1]')
abline(v = B[2,1])
plot(Bs[3,], kl, type = "l", main = 'solid line: true [1,2]')
abline(v = B[1,2])
plot(Bs[4,], kl, type = "l", main = 'solid line: true [2,2]')
abline(v = B[2,2])
par(mfrow = c(1,1))
U1 = U[sample(1:Size, 1)][[1]]
theta_star = seq(0, pi, length.out = 1000) %>% as.matrix()
kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = parallel::detectCores()-1)
par(mar = c(2,1,2,1))
plot(theta_star, kl, type = "l", main = 'solid line: true theta')
abline(v = theta)
Bs = pbapply::pbapply(theta_star, 1, .get_B, C = C)
par(mfrow = c(2,2))
plot(Bs[1,], kl, type = "l", main = 'solid line: true [1,1]')
abline(v = B[1,1])
plot(Bs[2,], kl, type = "l", main = 'solid line: true [2,1]')
abline(v = B[2,1])
plot(Bs[3,], kl, type = "l", main = 'solid line: true [1,2]')
abline(v = B[1,2])
plot(Bs[4,], kl, type = "l", main = 'solid line: true [2,2]')
abline(v = B[2,2])
par(mfrow = c(1,1))
?density
setwd("~/ownCloud/MS_Oil")
library(magrittr)
library(kdensity)
rm(list = ls())
# fun ---------------------------------------------------------------------
.make_dat = function(x, Tob, dof, B, dist = 'tdist'){
Epsilon = matrix(NA, nrow = Tob, ncol = 2)
for (k in 1:2) {
Epsilon[,k] = rt(Tob, dof[k])*sqrt((dof[k] - 2)/dof[k])
}
u = B %*% t(Epsilon)
t(u)
}
.get_kl0 = function(theta, u, C, kernel = "gaussian", bw = NULL){
#u = U1
Q  = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
xx = t(solve(C %*% Q) %*% t(u))
out = 0
for (i in 1:2) {
kd  = kdensity(xx[,i])#, kernel = kernel, bw = bw)
out = out + sum(log(kd(xx[,i])))
}
out
}
.get_B = function(theta, C){
Q  = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
C %*% Q
}
# DGP ---------------------------------------------------------------------
Size  = 10
Tob   = 60
dof   = c(3,5)
rho   = 0.4 #cov(u1,u2)
theta = pi/3
C     = matrix(c(1, 0, rho, sqrt(1-rho^2)), nrow = 2, ncol = 2, byrow = T)
Q     = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
B     = C %*% Q
U = vector("list", length = Size)
U = pbapply::pblapply(U, .make_dat, Tob = Tob, dof = dof, B = B, cl = parallel::detectCores()-1)
# 1 sample ----------------------------------------------------------------
U1 = U[sample(1:Size, 1)][[1]]
theta_star = seq(0, pi/2, length.out = 1000) %>% as.matrix()
#kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = parallel::detectCores()-1)
.get_kl0(theta, u = U1, C = C)
Rcpp::sourceCpp('get_kl.cpp')
kl_fast(theta, u = U1, C = C)
Rcpp::sourceCpp('get_kl.cpp')
Rcpp::sourceCpp('get_kl.cpp')
kl_fast(theta, u = U1, C = C)
Rcpp::sourceCpp('get_kl.cpp')
Rcpp::sourceCpp('get_kl.cpp')
kl_fast(theta, u = U1, C = C)
Rcpp::sourceCpp('get_kl.cpp')
Rcpp::sourceCpp('get_kl.cpp')
kl_fast(theta, u = U1, C = C)
Rcpp::sourceCpp('get_kl.cpp')
Rcpp::sourceCpp('get_kl.cpp')
kl_fast(theta, u = U1, C = C)
Rcpp::sourceCpp('get_kl.cpp')
kl_fast(theta, u = U1, C = C)
#kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = parallel::detectCores()-1)
.get_kl0(theta, u = U1, C = C)
-69.0254 + -69.7138
Rcpp::sourceCpp('get_kl.cpp')
kl_fast(theta, u = U1, C = C)
#kl = pbapply::pbapply(theta_star, 1, .get_kl0, u = U1, C = C, cl = parallel::detectCores()-1)
.get_kl0(theta, u = U1, C = C)
setwd("~/ownCloud/Markov_Switching_SVAR/run")
Rcpp::sourceCpp('../fun/kl_fast.cpp')
rm(list = ls())
#source('reduced_form.R')
library(magrittr)
library(kdensity)
Rcpp::sourceCpp('../fun/kl_fast.cpp')
# fun ---------------------------------------------------------------------
# this function simulates unobserved independent component from
# standardized t distribution and mixes them with a B matrix
# the output is the observable
.make_dat = function(x, Tob, dof, B, dist = 'tdist'){
Epsilon = matrix(NA, nrow = Tob, ncol = 2)
for (k in 1:2) {
Epsilon[,k] = rt(Tob, dof[k])*sqrt((dof[k] - 2)/dof[k])
}
u = B %*% t(Epsilon)
t(u)
}
# this function calculates log kernel likelihood
get_kl0 = function(theta, u, C, kernel = "gaussian", bw = NULL){
Q  = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
xx = t(solve(C %*% Q) %*% t(u))
out = 0
for (i in 1:2) {
kd  = kdensity(xx[,i])#, kernel = kernel, bw = bw)
out = out + sum(log(kd(xx[,i])))
}
out
}
# DGP ---------------------------------------------------------------------
Tob   = 60
dof   = c(3,5)
rho   = 0.4 #cov(u1,u2)
theta = pi/3
C     = matrix(c(1, 0, rho, sqrt(1-rho^2)), nrow = 2, ncol = 2, byrow = T)
Q     = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
B     = C %*% Q
# fun ---------------------------------------------------------------------
# this function simulates unobserved independent component from
# standardized t distribution and mixes them with a B matrix
# the output is the observable
make_dat = function(x, Tob, dof, B, dist = 'tdist'){
Epsilon = matrix(NA, nrow = Tob, ncol = 2)
for (k in 1:2) {
Epsilon[,k] = rt(Tob, dof[k])*sqrt((dof[k] - 2)/dof[k])
}
u = B %*% t(Epsilon)
t(u)
}
# this function calculates log kernel likelihood
get_kl0 = function(theta, u, C, kernel = "gaussian", bw = NULL){
Q  = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
xx = t(solve(C %*% Q) %*% t(u))
out = 0
for (i in 1:2) {
kd  = kdensity(xx[,i])#, kernel = kernel, bw = bw)
out = out + sum(log(kd(xx[,i])))
}
out
}
# DGP ---------------------------------------------------------------------
Tob   = 60
dof   = c(3,5)
rho   = 0.4 #cov(u1,u2)
theta = pi/3
C     = matrix(c(1, 0, rho, sqrt(1-rho^2)), nrow = 2, ncol = 2, byrow = T)
Q     = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
B     = C %*% Q
U = make_dat(0, Tob = Tob, dof = dof, B = B)
# caculate log kernel likelihood at true theta ----------------------------
get_kl0(theta, u = U1, C = C)
# caculate log kernel likelihood at true theta ----------------------------
get_kl0(theta, u = U, C = C)
# caculate log kernel likelihood at true theta ----------------------------
get_kl0(theta, u = U, C = C)
kl_fast(theta, u = U, C = C)
# caculate log kernel likelihood at true theta ----------------------------
get_kl0(theta, u = U, C = C)
kl_fast(theta, u = U, C = C)
rm(list = ls())
library(magrittr)
library(kdensity)
Rcpp::sourceCpp('../fun/kl_fast.cpp')
// K = 3
arma::mat Q = arma::eye(3, 3);
for (int i = 0; i < 3; i++)
{
arma::mat temp = arma::eye(3, 3);
temp(0, 0) = cos(theta(i));
temp(1, 1) = cos(theta(i));
temp(0, 1) = -sin(theta(i));
temp(1, 0) = sin(theta(i));
Q = Q * temp;
}
arma::mat E = arma::inv(C * Q) * u.t();
double out = 0;
for (int i = 0; i < 3; i++)
{
out = out + sum(log(kdensity(E.row(i).t())));
}
return out;
}
rm(list = ls())
#source('reduced_form.R')
library(magrittr)
library(kdensity)
Rcpp::sourceCpp('../fun/kl_fast.cpp')
# fun ---------------------------------------------------------------------
# this function simulates unobserved independent component from
# standardized t distribution and mixes them with a B matrix
# the output is the observable
make_dat = function(x, Tob, dof, B, dist = 'tdist'){
Epsilon = matrix(NA, nrow = Tob, ncol = 2)
for (k in 1:2) {
Epsilon[,k] = rt(Tob, dof[k])*sqrt((dof[k] - 2)/dof[k])
}
u = B %*% t(Epsilon)
t(u)
}
# this function calculates kernel log likelihood
get_kl0 = function(theta, u, C, kernel = "gaussian", bw = NULL){
Q  = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
xx = t(solve(C %*% Q) %*% t(u))
out = 0
for (i in 1:2) {
kd  = kdensity(xx[,i])#, kernel = kernel, bw = bw)
out = out + sum(log(kd(xx[,i])))
}
out
}
# DGP ---------------------------------------------------------------------
Tob   = 60
dof   = c(3,5)
rho   = 0.4 #cov(u1,u2)
theta = pi/3
C     = matrix(c(1, 0, rho, sqrt(1-rho^2)), nrow = 2, ncol = 2, byrow = T)
Q     = matrix(c(cos(theta), -sin(theta), sin(theta), cos(theta)), nrow = 2, ncol = 2, byrow = T)
B     = C %*% Q
U = make_dat(0, Tob = Tob, dof = dof, B = B)
# calculate kernel log likelihood at true theta ---------------------------
get_kl0(theta, u = U, C = C)
kl_fast(theta, u = U, C = C)
# compare speed -----------------------------------------------------------
bench = microbenchmark::microbenchmark("R" = get_kl0(theta, u = U, C = C),
"Rcpp1" = kl_fast(theta, u = U, C = C),
"Rcpp2" = kl_fast2D(theta, u = U, C = C),
times = 100)
kl_fast2D(theta, u = U, C = C)
# calculate kernel log likelihood at true theta ---------------------------
get_kl0(theta, u = U, C = C)
kl_fast(theta, u = U, C = C)
kl_fast2D(theta, u = U, C = C)
require(ggfortify)
bench %>% autoplot
bench %>% show
